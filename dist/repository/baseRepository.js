/* eslint-disable @typescript-eslint/ban-ts-comment */
// Keep in mind that this file is automatically generated.
import _ from "lodash";
export const extractCondition = (conditions) => {
    const dbCond = _.isObject(conditions)
        ? conditions
        : { id: _.toNumber(conditions) };
    return dbCond;
};
/**
 * @param modelName - The model name
 */
const BaseRepository = (modelName) => {
    class AbstractBaseRepository {
        static modelName = modelName;
        /**
         * Find zero or more `model` that matches the filter.\
         * Note, that providing `undefined` is treated as the value not being there.
         */
        static async findAll(conditions, filterQueryParams = {}, query = {}, option = {}) {
            const limit = +(query.limit === "all" ? 0 : _.get(query, "limit", 10));
            const offset = query.page && query.page > 0 ? limit * (query.page - 1) : 0;
            const otherOptions = _.omit(query, ["limit", "offset", "page"]);
            const where = {
                ...extractCondition(conditions),
                ...filterQueryParams,
                ...otherOptions,
            };
            return {
                // @ts-ignore
                rows: (await AbstractBaseRepository.model.findMany({
                    // @ts-ignore
                    where,
                    ...option,
                    skip: offset,
                    ...(limit > 0 && { take: limit }),
                })),
                /* @ts-ignore */
                count: await this.count(where),
            };
        }
        /**
         * Alternative of `findAll`.\
         * It works same as `findOne` but only have different names.\
         * It exists for anyone who prefer to use prisma `functions` original name.
         */
        static async findMany(...params) {
            return AbstractBaseRepository.findAll(...params);
        }
        /**
         * Find the first `model` that matches the filter.\
         * Note, that providing `undefined` is treated as the value not being there.
         */
        static async findOne(conditions, option = {}) {
            const where = extractCondition(conditions);
            // @ts-ignore
            return AbstractBaseRepository.model.findFirst({
                // @ts-ignore
                where,
                ...option,
            });
        }
        /**
         * Alternative of `findOne`.\
         * It works same as `findOne` but only have different names.\
         * It exists for anyone who prefer to use prisma `functions` original name.
         */
        static async findFirst(...params) {
            return AbstractBaseRepository.findOne(...params);
        }
        /**
         * Find zero or one `model` that matches the filter.\
         * Note, that providing `undefined` is treated as the value not being there.\
         * It works same as `findOne` or `findFirst` but only accept a unique column.
         */
        static async findUnique(conditions, option = {}) {
            const where = extractCondition(conditions);
            // @ts-ignore
            return AbstractBaseRepository.model.findUnique({
                // @ts-ignore
                where,
                ...option,
            });
        }
        /**
         * Create a `model`.
         */
        static async create(data, option = {}) {
            // @ts-ignore
            return AbstractBaseRepository.model.create({
                data,
                ...option,
            });
        }
        /**
         * Update a `model`.
         */
        static async update(conditions, data, option = {}) {
            const where = extractCondition(conditions);
            // @ts-ignore
            return AbstractBaseRepository.model.update({
                data,
                // @ts-ignore
                where,
                ...option,
            });
        }
        /**
         * Delete any `model` that match with the conditions.
         */
        static async delete(conditions) {
            const where = extractCondition(conditions);
            // @ts-ignore
            return AbstractBaseRepository.model.deleteMany({
                // @ts-ignore
                where,
            });
        }
        /**
         * Delete a `model`.
         */
        static async deleteOne(conditions, options = {}) {
            const where = extractCondition(conditions);
            // @ts-ignore
            return AbstractBaseRepository.model.delete({
                // @ts-ignore
                where,
                ...options,
            });
        }
        /**
         * Create or update one `model`.
         */
        static async updateOrCreate(conditions, data, option = {}) {
            const obj = await AbstractBaseRepository.findOne(conditions, option);
            if (obj)
                return AbstractBaseRepository.update(conditions, data, option);
            return AbstractBaseRepository.create(data);
        }
        /**
         * Alternative of `updateOrCreate`.\
         * It works same as `updateOrCreate` but only have different names.\
         * It exists for anyone who prefer to use prisma `functions` original name.
         */
        static async upsert(...params) {
            return AbstractBaseRepository.updateOrCreate(...params);
        }
        /**
         * Create many `model`.
         */
        static async bulkCreate(data, skipDuplicates = true) {
            // @ts-ignore
            return AbstractBaseRepository.model.createMany({
                data,
                // @ts-ignore
                skipDuplicates,
            });
        }
        /**
         * Alternative of `bulkCreate`.\
         * It works same as `bulkCreate` but only have different names.\
         * It exists for anyone who prefer to use prisma `functions` original name.
         */
        static async createMany(...params) {
            return AbstractBaseRepository.bulkCreate(...params);
        }
        /**
         * Update zero or more `model`.
         * Note, that providing `undefined` is treated as the value not being there.
         */
        static async bulkUpdate(where, data) {
            // @ts-ignore
            return AbstractBaseRepository.model.updateMany({
                data,
                where,
            });
        }
        /**
         * Alternative of `bulkUpdate`.\
         * It works same as `bulkUpdate` but only have different names.\
         * It exists for anyone who prefer to use prisma `functions` original name.
         */
        static async updateMany(...params) {
            return AbstractBaseRepository.bulkUpdate(...params);
        }
        /**
         * Count the number of `model`.\
         * Note, that providing `undefined` is treated as the value not being there.
         */
        static async count(conditions, option = {}) {
            const where = extractCondition(conditions);
            // @ts-ignore
            return AbstractBaseRepository.model.count({
                // @ts-ignore
                where,
                ...option,
            });
        }
        static async groupBy(conditions, aggregator) {
            const where = extractCondition(conditions);
            // @ts-ignore
            return AbstractBaseRepository.model.groupBy({
                // @ts-ignore
                where,
                ...aggregator,
            });
        }
    }
    return AbstractBaseRepository;
};
export default BaseRepository;
